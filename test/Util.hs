{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE TypeApplications #-}

module Util where

import Control.Monad ((<=<))
import Data.Aeson (eitherDecode)
import qualified Data.ByteString.Lazy as ByteStringL
import qualified Data.ByteString.Lazy.Char8 as Char8L
import Language.Haskell.TH
import Language.Haskell.TH.Quote (QuasiQuoter(..))
import Language.Haskell.TH.Syntax (lift)

import Data.Aeson.Schema (Object, schema, unwrap)
import Data.Aeson.Schema.Internal (prettyShow)

getMockedResult :: FilePath -> ExpQ
getMockedResult fp = do
  contents <- runIO $ ByteStringL.readFile fp
  [| either error id $ eitherDecode $ Char8L.pack $(lift $ Char8L.unpack contents) |]

-- | Show the type generated by passing the given string to the 'unwrap' quasiquoter.
showUnwrap :: String -> ExpQ
showUnwrap = showType <=< quoteType unwrap

-- | Show the type generated by passing the given string to the 'schema' quasiquoter.
showSchema :: String -> ExpQ
showSchema = showSchemaType <=< quoteType schema

showType :: Type -> ExpQ
showType = \case
  AppT (ConT name) schema' | name == ''Object -> [| "Object (" ++ $(showSchemaType schema') ++ ")" |]
  ty -> lift $ pprint ty

showSchemaType :: Type -> ExpQ
showSchemaType = appTypeE [| prettyShow |] . pure
